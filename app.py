
"""
app.py - Simple Flask app skeleton for an IRCTC/stocks prediction app.

Features:
 - Simple web form to submit a ticker and get a prediction response.
 - Attempts to load a scikit-learn model 'model.pkl' and scaler 'scaler.pkl' from the working directory.
 - Safe `if __name__ == "__main__":` guard to avoid "signal only works in main thread" errors on Windows.
 - Runs the Flask server with the reloader disabled (use_reloader=False) to avoid issues with signal handlers when running in non-standard environments.
 - Returns JSON for API clients and a tiny HTML form for manual testing.

If you have a trained model:
 - Save it as "model.pkl" (joblib.dump) in the same directory.
 - If you used a scaler, save as "scaler.pkl".

Suggested requirements:
flask
joblib
pandas
scikit-learn

Author: Generated by ChatGPT
"""
import os
import traceback
from flask import Flask, request, jsonify, render_template_string

try:
    import joblib
except Exception:
    joblib = None

app = Flask(__name__)

# Simple HTML form for manual testing
HTML_PAGE = """
<!doctype html>
<title>Stock Prediction - Demo</title>
<h1>Stock Prediction Demo</h1>
<form method="post" action="/predict">
  Ticker (e.g. IRCTC): <input type="text" name="ticker" value="IRCTC"><br><br>
  Feature values (comma-separated) e.g. 1.2,3.4,5.6:<br>
  <input type="text" name="features" size="60" value="0.1,0.2,0.3"><br><br>
  <input type="submit" value="Predict">
</form>
<p>Use the /api/predict endpoint for JSON requests.</p>
"""

def load_model(model_path='model.pkl', scaler_path='scaler.pkl'):
    """
    Try to load model and scaler. If joblib is not installed or files don't exist, returns (None, None).
    """
    model = None
    scaler = None
    if joblib is None:
        app.logger.warning("joblib not available; cannot load model.")
        return None, None
    try:
        if os.path.exists(model_path):
            model = joblib.load(model_path)
            app.logger.info(f"Loaded model from {model_path}")
        else:
            app.logger.info(f"Model file not found at {model_path}")
        if os.path.exists(scaler_path):
            scaler = joblib.load(scaler_path)
            app.logger.info(f"Loaded scaler from {scaler_path}")
        else:
            app.logger.info(f"Scaler file not found at {scaler_path}")
    except Exception as e:
        app.logger.error("Failed to load model/scaler: %s", e)
        app.logger.debug(traceback.format_exc())
    return model, scaler

# Lazy-load model on first request
_MODEL = None
_SCALER = None

@app.route('/', methods=['GET'])
def index():
    return render_template_string(HTML_PAGE)

@app.route('/predict', methods=['POST'])
def predict_form():
    """
    Endpoint used by the simple HTML form.
    Expects:
    - 'ticker' (string)
    - 'features' (comma-separated numeric values)
    """
    global _MODEL, _SCALER
    ticker = request.form.get('ticker', '').strip()
    features_raw = request.form.get('features', '').strip()
    if not features_raw:
        return "No feature values provided. Provide comma-separated numbers.", 400
    try:
        features = [float(x) for x in features_raw.split(',') if x.strip()!='']
    except ValueError:
        return "Could not parse feature values. Ensure they are numeric and comma-separated.", 400

    if _MODEL is None:
        _MODEL, _SCALER = load_model()

    if _MODEL is None:
        # No model, return a dummy response for demo purposes
        demo_pred = sum(features) / max(1, len(features))
        return render_template_string("<h2>Demo prediction for {{t}}</h2><p>Input features: {{f}}</p><p>Demo prediction (mean): {{p}}</p>",
                                      t=ticker, f=features, p=demo_pred)

    # If scaler exists, transform features
    import numpy as np
    X = np.array(features).reshape(1, -1)
    if _SCALER is not None:
        try:
            X = _SCALER.transform(X)
        except Exception as e:
            app.logger.warning("Scaler transform failed: %s", e)

    try:
        pred = _MODEL.predict(X)
        return render_template_string("<h2>Prediction for {{t}}</h2><p>Input features: {{f}}</p><p>Model prediction: {{p}}</p>",
                                      t=ticker, f=features, p=pred.tolist())
    except Exception as e:
        app.logger.error("Model prediction failed: %s", e)
        return "Model prediction failed. Check server logs.", 500

@app.route('/api/predict', methods=['POST'])
def api_predict():
    """
    JSON API for predictions.
    Accepts JSON body:
    {
      "ticker": "IRCTC",
      "features": [0.1, 0.2, 0.3]
    }
    """
    global _MODEL, _SCALER
    data = request.get_json(force=True, silent=True)
    if data is None:
        return jsonify({"error": "Invalid or missing JSON body."}), 400
    features = data.get('features')
    ticker = data.get('ticker', '')
    if not isinstance(features, (list, tuple)) or len(features) == 0:
        return jsonify({"error": "Provide 'features' as a non-empty list of numbers."}), 400
    try:
        import numpy as np
        X = np.array([float(x) for x in features]).reshape(1, -1)
    except Exception:
        return jsonify({"error": "Could not parse features into floats."}), 400

    if _MODEL is None:
        _MODEL, _SCALER = load_model()

    if _MODEL is None:
        # Return a dummy result when there's no model available
        demo_pred = float(X.mean())
        return jsonify({
            "ticker": ticker,
            "prediction": demo_pred,
            "note": "No trained model found; returning demo mean of input features."
        })

    if _SCALER is not None:
        try:
            X = _SCALER.transform(X)
        except Exception as e:
            app.logger.warning("Scaler transform failed: %s", e)

    try:
        pred = _MODEL.predict(X)
        # If pred is array-like, try to convert to Python types
        pred_out = pred.tolist() if hasattr(pred, 'tolist') else pred
        return jsonify({
            "ticker": ticker,
            "prediction": pred_out
        })
    except Exception as e:
        app.logger.error("Prediction failed: %s", e)
        return jsonify({"error": "Prediction failed on server. Check logs."}), 500

if __name__ == "__main__":
    # Important: keep use_reloader=False on Windows and some hosting environments to avoid
    # "ValueError: signal only works in main thread" caused by the reloader using signal handlers.
    # If you need auto-reload in development, consider using a proper development server or run with debug tools.
    app.run(host="0.0.0.0", port=5000, debug=True, use_reloader=False)
